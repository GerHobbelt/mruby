From 3d33e7b86e45f5a57957c04020c27ea769174185 Mon Sep 17 00:00:00 2001
From: "Yukihiro \"Matz\" Matsumoto" <matz@ruby.or.jp>
Date: Tue, 14 Dec 2021 13:35:18 +0900
Subject: [PATCH] proc.c: add `mrb_state` argument to `mrb_proc_copy()`.

The function may invoke the garbage collection and it requires
`mrb_state` to run.

(cherry picked from commit f5e10c5a79a17939af763b1dcf5232ce47e24a34)
Signed-off-by: Nobuhiro Iwamatsu <iwamatsu@debian.org>
Reference: CVE-2021-4110
Bug-Debian: http://bugs.debian.org/1001768
Origin: https://github.com/mruby/mruby/commit/f5e10c5a79a17939af763b1dcf5232ce47e24a34
---
 include/mruby/proc.h |  2 +-
 src/class.c          |  2 +-
 src/proc.c           | 12 ++++++------
 3 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/include/mruby/proc.h b/include/mruby/proc.h
index 0edd3e1f1..2593c8a9a 100644
--- a/include/mruby/proc.h
+++ b/include/mruby/proc.h
@@ -90,7 +90,7 @@ struct RProc *mrb_proc_new(mrb_state*, const mrb_irep*);
 struct RProc *mrb_closure_new(mrb_state*, const mrb_irep*);
 MRB_API struct RProc *mrb_proc_new_cfunc(mrb_state*, mrb_func_t);
 MRB_API struct RProc *mrb_closure_new_cfunc(mrb_state *mrb, mrb_func_t func, int nlocals);
-void mrb_proc_copy(struct RProc *a, struct RProc *b);
+void mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b);
 mrb_int mrb_proc_arity(const struct RProc *p);
 
 /* following functions are defined in mruby-proc-ext so please include it when using */
diff --git a/src/class.c b/src/class.c
index 09e52d24a..6d03aa462 100644
--- a/src/class.c
+++ b/src/class.c
@@ -2511,7 +2511,7 @@ mrb_mod_define_method_m(mrb_state *mrb, struct RClass *c)
     mrb_raise(mrb, E_ARGUMENT_ERROR, "no block given");
   }
   p = (struct RProc*)mrb_obj_alloc(mrb, MRB_TT_PROC, mrb->proc_class);
-  mrb_proc_copy(p, mrb_proc_ptr(blk));
+  mrb_proc_copy(mrb, p, mrb_proc_ptr(blk));
   p->flags |= MRB_PROC_STRICT;
   MRB_METHOD_FROM_PROC(m, p);
   mrb_define_method_raw(mrb, c, mid, m);
diff --git a/src/proc.c b/src/proc.c
index 870d5ea16..b72463617 100644
--- a/src/proc.c
+++ b/src/proc.c
@@ -184,7 +184,7 @@ mrb_proc_cfunc_env_get(mrb_state *mrb, mrb_int idx)
 }
 
 void
-mrb_proc_copy(struct RProc *a, struct RProc *b)
+mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)
 {
   if (a->body.irep) {
     /* already initialized proc */
@@ -192,10 +192,10 @@ mrb_proc_copy(struct RProc *a, struct RProc *b)
   }
   a->flags = b->flags;
   a->body = b->body;
+  a->upper = b->upper;
   if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {
-    mrb_irep_incref(NULL, (mrb_irep*)a->body.irep);
+    mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);
   }
-  a->upper = b->upper;
   a->e.env = b->e.env;
   /* a->e.target_class = a->e.target_class; */
 }
@@ -210,7 +210,7 @@ mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)
   /* Calling Proc.new without a block is not implemented yet */
   mrb_get_args(mrb, "&!", &blk);
   p = (struct RProc *)mrb_obj_alloc(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));
-  mrb_proc_copy(p, mrb_proc_ptr(blk));
+  mrb_proc_copy(mrb, p, mrb_proc_ptr(blk));
   proc = mrb_obj_value(p);
   mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);
   if (!MRB_PROC_STRICT_P(p) &&
@@ -228,7 +228,7 @@ mrb_proc_init_copy(mrb_state *mrb, mrb_value self)
   if (!mrb_proc_p(proc)) {
     mrb_raise(mrb, E_ARGUMENT_ERROR, "not a proc");
   }
-  mrb_proc_copy(mrb_proc_ptr(self), mrb_proc_ptr(proc));
+  mrb_proc_copy(mrb, mrb_proc_ptr(self), mrb_proc_ptr(proc));
   return self;
 }
 
@@ -264,7 +264,7 @@ proc_lambda(mrb_state *mrb, mrb_value self)
   p = mrb_proc_ptr(blk);
   if (!MRB_PROC_STRICT_P(p)) {
     struct RProc *p2 = (struct RProc*)mrb_obj_alloc(mrb, MRB_TT_PROC, p->c);
-    mrb_proc_copy(p2, p);
+    mrb_proc_copy(mrb, p2, p);
     p2->flags |= MRB_PROC_STRICT;
     return mrb_obj_value(p2);
   }
-- 
2.34.1

